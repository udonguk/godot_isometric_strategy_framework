# ì•„í‚¤í…ì²˜ ê°€ì´ë“œë¼ì¸ (Architecture Guidelines)

ì´ ë¬¸ì„œëŠ” "isometric_strategy_framework" í”„ë¡œì íŠ¸ì˜ ì•„í‚¤í…ì²˜ ì„¤ê³„ ì›ì¹™, ë””ìì¸ íŒ¨í„´, ê·¸ë¦¬ê³  êµ¬ì¡°ì  ê·œì¹™ì„ ì •ì˜í•©ë‹ˆë‹¤.

## 1. ì”¬ ìš°ì„  ê°œë°œ (Scene-First Development)

**í•µì‹¬**: ëª¨ë“  ê¸°ëŠ¥ì€ **ì”¬(.tscn) íŒŒì¼ë¡œ ë¨¼ì €** êµ¬í˜„í•©ë‹ˆë‹¤.

### ê°œë°œ ì ˆì°¨
1. **ì”¬ ìƒì„±** (`scenes/` í´ë”)
   - Godot ì—ë””í„°ì—ì„œ ì”¬ ìƒì„±
   - í•„ìš”í•œ ë…¸ë“œ êµ¬ì¡° êµ¬ì„±

2. **ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±** (`scripts/` í´ë”)
   - ì”¬ì— ì—°ê²°í•  ë¡œì§ ì‘ì„±
   - ë…¸ë“œ íƒ€ì… ìƒì† (ì˜ˆ: `extends Camera2D`)

3. **ì”¬ê³¼ ìŠ¤í¬ë¦½íŠ¸ ì—°ê²°**
   - ì—ë””í„°ì—ì„œ ìŠ¤í¬ë¦½íŠ¸ attach
   - ë…¸ë“œ ë ˆí¼ëŸ°ìŠ¤ ì„¤ì • (`@onready`)

### ì˜ˆì‹œ: ì¹´ë©”ë¼ ì‹œìŠ¤í…œ

```
âœ… ì˜¬ë°”ë¥¸ ë°©ë²•:
1. scenes/camera/rts_camera.tscn ìƒì„± (Camera2D ë…¸ë“œ)
2. scripts/camera/rts_camera.gd ì‘ì„± (extends Camera2D)
3. ì”¬ì— ìŠ¤í¬ë¦½íŠ¸ ì—°ê²°
4. test_map.tscnì—ì„œ ì¸ìŠ¤í„´ìŠ¤í™”

âŒ ì˜ëª»ëœ ë°©ë²•:
- ìŠ¤í¬ë¦½íŠ¸ë§Œ ì‘ì„± í›„ ì½”ë“œë¡œ ë…¸ë“œ ìƒì„±
  var cam = Camera2D.new()
  add_child(cam)
```

### í´ë” êµ¬ì¡° ê·œì¹™
```
scenes/camera/rts_camera.tscn    # ì”¬ íŒŒì¼
scripts/camera/rts_camera.gd     # ìŠ¤í¬ë¦½íŠ¸ (ê°™ì€ ì´ë¦„)
```

### ì¥ì 
- **ì¬ì‚¬ìš©ì„±**: ì—¬ëŸ¬ ì”¬ì—ì„œ ì¸ìŠ¤í„´ìŠ¤í™”
- **ì‹œê°ì  í¸ì§‘**: ì—ë””í„°ì—ì„œ ë…¸ë“œ êµ¬ì¡° í™•ì¸
- **Godot ì² í•™**: "Everything is a Scene"

## 2. ê°ì²´ ì§€í–¥ ë° êµìœ¡ì  ì½”ë“œ ì‘ì„± (OOP & Learning)
- **ì±…ì„ ë¶„ë¦¬**: ê° ìŠ¤í¬ë¦½íŠ¸ëŠ” í•˜ë‚˜ì˜ ëª…í™•í•œ ì—­í• ë§Œ ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤ (ë‹¨ì¼ ì±…ì„ ì›ì¹™).
- **ìƒì† í™œìš©**: ê³µí†µ ê¸°ëŠ¥ì€ ë¶€ëª¨ í´ë˜ìŠ¤ë¡œ ì¶”ìƒí™”í•©ë‹ˆë‹¤ (ì˜ˆ: `BaseEnemy` -> `GoblinEnemy`).
- **êµìœ¡ì  ì£¼ì„(Why)**: íŠ¹ì • ë””ìì¸ íŒ¨í„´ì´ë‚˜ ë³µì¡í•œ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•  ë•ŒëŠ” **"ì™œ ì´ íŒ¨í„´ì„ ì‚¬ìš©í–ˆëŠ”ì§€"** ì£¼ì„ìœ¼ë¡œ ì„¤ëª…ì„ ë‚¨ê¹ë‹ˆë‹¤.
  ```gdscript
  # [State Pattern] ìƒíƒœë³„ ë¡œì§ ë¶„ë¦¬ë¥¼ í†µí•´ ì½”ë“œ ë³µì¡ë„ë¥¼ ë‚®ì¶”ê³  ìœ ì§€ë³´ìˆ˜ì„±ì„ ë†’ì´ê¸° ìœ„í•´ ì‚¬ìš©
  # IdleStateëŠ” ê°€ë§Œíˆ ì„œìˆì„ ë•Œì˜ í–‰ë™ì„ ì •ì˜í•©ë‹ˆë‹¤.
  class_name IdleState extends State
  ```

## 3. ë””ìì¸ íŒ¨í„´ (Design Patterns)

Godot ê°œë°œ íš¨ìœ¨ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ë¥¼ ìœ„í•´ ë‹¤ìŒ íŒ¨í„´ ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤.

### 3.1. ìƒíƒœ íŒ¨í„´ (State Pattern)
- **ìš©ë„**: ìºë¦­í„°(í”Œë ˆì´ì–´, AI)ì˜ ë³µì¡í•œ ìƒíƒœ ì „ì´(ëŒ€ê¸° -> ì´ë™ -> ê³µê²©)ë¥¼ ê´€ë¦¬í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
- **êµ¬ì¡°**: `StateMachine` ë…¸ë“œê°€ í˜„ì¬ ìƒíƒœ(`State` ë…¸ë“œ)ë¥¼ ê´€ë¦¬í•˜ë©°, ê° ìƒíƒœëŠ” ë³„ë„ì˜ ìŠ¤í¬ë¦½íŠ¸ë¡œ ë¶„ë¦¬í•©ë‹ˆë‹¤.
- **ì¥ì **: ê±°ëŒ€í•œ `if-else` ë˜ëŠ” `switch` ë¬¸ì„ í”¼í•˜ê³ , ê° ìƒíƒœë³„ ë¡œì§ì„ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 3.2. ì»´í¬ë„ŒíŠ¸ íŒ¨í„´ (Component Pattern)
- **ìš©ë„**: ê¸°ëŠ¥ì˜ ì¬ì‚¬ìš©ì„±ì„ ê·¹ëŒ€í™”í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•©ë‹ˆë‹¤. "ìƒì†ë³´ë‹¤ëŠ” êµ¬ì„±(Composition over Inheritance)" ì›ì¹™ì„ ë”°ë¦…ë‹ˆë‹¤.
- **êµ¬ì¡°**: `HealthComponent`, `HitboxComponent`ì™€ ê°™ì´ íŠ¹ì • ê¸°ëŠ¥ë§Œ ìˆ˜í–‰í•˜ëŠ” ë…¸ë“œë¥¼ ë§Œë“¤ê³ , ì´ë¥¼ ìºë¦­í„°ë‚˜ ì˜¤ë¸Œì íŠ¸ì— ë¶€ì°©í•˜ì—¬ ì¡°ë¦½í•©ë‹ˆë‹¤.
- **ì¥ì **: ë¶€ëª¨ í´ë˜ìŠ¤ê°€ ë„ˆë¬´ ë¹„ëŒ€í•´ì§€ëŠ” ê²ƒì„ ë°©ì§€í•˜ê³ , ë‹¤ì–‘í•œ ê¸°ëŠ¥ì„ ìœ ì—°í•˜ê²Œ ì¡°í•©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 3.3. ì‹±ê¸€í†¤ íŒ¨í„´ (Singleton Pattern / Autoload)
- **ìš©ë„**: ê²Œì„ ì „ì²´ì—ì„œ ê³µìœ í•´ì•¼ í•˜ëŠ” ë°ì´í„°ë‚˜ ë§¤ë‹ˆì €(ì˜ˆ: `GameManager`, `SoundManager`)ì— ì‚¬ìš©í•©ë‹ˆë‹¤.
- **Godot êµ¬í˜„**: í”„ë¡œì íŠ¸ ì„¤ì •ì˜ **Autoload** ê¸°ëŠ¥ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
- **ì£¼ì˜**: ê³¼ë„í•œ ì‚¬ìš©ì€ ì˜ì¡´ì„±ì„ ë†’ì´ë¯€ë¡œ ê¼­ í•„ìš”í•œ ì „ì—­ ê´€ë¦¬ì—ë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤.

#### Autoload ì‚¬ìš© ê·œì¹™ (ì¤‘ìš”!)
1. **Autoload ì´ë¦„ ì¶©ëŒ ë°©ì§€ (Shadowing ê¸ˆì§€)**
   - Autoloadë¡œ ë“±ë¡ëœ ì´ë¦„(ì˜ˆ: `GridSystem`)ê³¼ ë™ì¼í•œ ì´ë¦„ìœ¼ë¡œ `preload()`í•˜ê±°ë‚˜ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
   - **âŒ ì˜ëª»ëœ ì˜ˆ**: `const GridSystem = preload(...)` (ì „ì—­ ì‹±ê¸€í†¤ì„ ê°€ë ¤ë²„ë¦¼ -> ì˜¤ë¥˜ ë°œìƒ)
   - **âœ… ì˜¬ë°”ë¥¸ ì˜ˆ**: Autoload ì´ë¦„ì€ ì „ì—­ì—ì„œ ë°”ë¡œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë¯€ë¡œ `preload` ì—†ì´ ì‚¬ìš©

2. **ëª…í™•í•œ íƒ€ì… êµ¬ë¶„ (class_name)**
   - Autoload ìŠ¤í¬ë¦½íŠ¸ì—ëŠ” `class_name`ì„ ì§€ì •í•˜ë˜, Autoload ì´ë¦„ê³¼ ë‹¤ë¥´ê²Œ ì§“ìŠµë‹ˆë‹¤.
   - ì˜ˆ: Autoload ì´ë¦„ì´ `GridSystem`ì´ë¼ë©´, ìŠ¤í¬ë¦½íŠ¸ ë‚´ `class_name`ì€ `GridSystemNode`ë¡œ ì§€ì •
   - ì´ë ‡ê²Œ í•˜ë©´ Godot íŒŒì„œê°€ **ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤**ì™€ **ìŠ¤í¬ë¦½íŠ¸ íƒ€ì…**ì„ ëª…í™•íˆ êµ¬ë¶„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## 4. Godot ë‚´ì¥ ê¸°ëŠ¥ ìš°ì„  ì‚¬ìš© (ì¤‘ìš”!)

**ì›ì¹™**: ê¸°ëŠ¥ êµ¬í˜„ ì‹œ **í•­ìƒ Godot ë‚´ì¥ ê¸°ëŠ¥ì„ ë¨¼ì € ê²€í† **í•˜ê³  í™œìš©

### ìš°ì„ ìˆœìœ„

1. **Godot ë‚´ì¥ ê¸°ëŠ¥** (ìµœìš°ì„ )
2. Godot í”ŒëŸ¬ê·¸ì¸/ì—ì…‹
3. ì§ì ‘ êµ¬í˜„ (ìµœí›„ì˜ ìˆ˜ë‹¨)

### ì£¼ìš” ë‚´ì¥ ê¸°ëŠ¥ í™œìš© ì˜ˆì‹œ

| ê¸°ëŠ¥ | âŒ ì§ì ‘ êµ¬í˜„ | âœ… Godot ë‚´ì¥ |
|------|------------|-------------|
| ê²½ë¡œ ì°¾ê¸° | A* ì§ì ‘ êµ¬í˜„ | **NavigationAgent2D + Navigation Layers** |
| ë¬¼ë¦¬ ì¶©ëŒ | ìˆ˜ë™ ì¶©ëŒ ì²´í¬ | **CollisionShape2D + Area2D** |
| ì• ë‹ˆë©”ì´ì…˜ | ìˆ˜ë™ í”„ë ˆì„ ì „í™˜ | **AnimatedSprite2D / AnimationPlayer** |
| íƒ€ì¼ë§µ | ìˆ˜ë™ ê·¸ë¦¬ë“œ | **TileMapLayer + TileSet** |
| ì…ë ¥ ì²˜ë¦¬ | í‚¤ë³´ë“œ ì§ì ‘ ì²´í¬ | **Input Actions (í”„ë¡œì íŠ¸ ì„¤ì •)** |
| ìƒíƒœ ë¨¸ì‹  | ìˆ˜ë™ êµ¬í˜„ | **AnimationTree / ì»¤ìŠ¤í…€ ë…¸ë“œ** |

### ìƒˆ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ì²´í¬ë¦¬ìŠ¤íŠ¸

ì½”ë“œë¥¼ ì‘ì„±í•˜ê¸° ì „ì— ë‹¤ìŒì„ í™•ì¸:

1. [ ] Godot ë¬¸ì„œì—ì„œ ê´€ë ¨ ë‚´ì¥ ê¸°ëŠ¥ ê²€ìƒ‰
2. [ ] TileMap, Navigation, Physics ë“± ê´€ë ¨ ì‹œìŠ¤í…œ í™•ì¸
3. [ ] ë‚´ì¥ ë…¸ë“œ íƒ€ì… ê²€í†  (Node2D, Area2D, CharacterBody2D ë“±)
4. [ ] ë‚´ì¥ ê¸°ëŠ¥ì´ ì—†ëŠ” ê²½ìš°ì—ë§Œ ì§ì ‘ êµ¬í˜„

### ì˜ˆì‹œ: ê²½ë¡œ ì°¾ê¸° êµ¬í˜„

**âŒ ì˜ëª»ëœ ì ‘ê·¼:**
```gdscript
# A* ì•Œê³ ë¦¬ì¦˜ ì§ì ‘ êµ¬í˜„
func find_path(start, end):
    var open_set = []
    var closed_set = []
    # 100ì¤„ì˜ A* ì½”ë“œ...
```

**âœ… ì˜¬ë°”ë¥¸ ì ‘ê·¼:**
```gdscript
# Godotì˜ NavigationAgent2D ì‚¬ìš©
@onready var nav_agent = $NavigationAgent2D

func move_to(target):
    nav_agent.target_position = target
    # Godotê°€ ìë™ìœ¼ë¡œ ê²½ë¡œ ì°¾ê¸° ì²˜ë¦¬
```

### í•™ìŠµ ë¦¬ì†ŒìŠ¤

- **Godot ê³µì‹ ë¬¸ì„œ**: ìƒˆ ê¸°ëŠ¥ ì „ì— í•­ìƒ í™•ì¸
- **Built-in ë…¸ë“œ ëª©ë¡**: ì—ë””í„°ì—ì„œ "Add Node" íƒìƒ‰
- **TileMap ì‹œìŠ¤í…œ**: Navigation Layers, Physics Layers, Custom Data

### ì´ì 

- âœ… ì„±ëŠ¥ ìµœì í™”ë¨
- âœ… ë²„ê·¸ ì ìŒ
- âœ… ìœ ì§€ë³´ìˆ˜ ì‰¬ì›€
- âœ… ì—ë””í„° í†µí•©
- âœ… ê°œë°œ ì†ë„ ë¹ ë¦„

**ì¤‘ìš”**: ë‚´ì¥ ê¸°ëŠ¥ì„ ëª¨ë¥´ê³  ì§ì ‘ êµ¬í˜„í•˜ë©´ ì‹œê°„ ë‚­ë¹„ + ì„±ëŠ¥ ì €í•˜!

## 5. SOLID ì›ì¹™ ì¤€ìˆ˜ (ì¤‘ìš”!)

**ì›ì¹™**: ëª¨ë“  ì½”ë“œëŠ” **SOLID ì›ì¹™**ì„ ì¤€ìˆ˜í•˜ì—¬ ì‘ì„±í•©ë‹ˆë‹¤

### ì™œ SOLIDê°€ ì¤‘ìš”í•œê°€?

ê²Œì„ ê°œë°œì€ ì§€ì†ì ì¸ ë³€ê²½ê³¼ í™•ì¥ì´ í•„ìš”í•©ë‹ˆë‹¤. SOLID ì›ì¹™ì„ ë”°ë¥´ì§€ ì•Šìœ¼ë©´:
- âŒ ì½”ë“œ ë³€ê²½ ì‹œ ì—¬ëŸ¬ ê³³ì„ ìˆ˜ì •í•´ì•¼ í•¨ (ìœ ì§€ë³´ìˆ˜ ì§€ì˜¥)
- âŒ ìƒˆ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ê¸°ì¡´ ì½”ë“œê°€ ë§ê°€ì§ (íšŒê·€ ë²„ê·¸)
- âŒ í…ŒìŠ¤íŠ¸í•˜ê¸° ì–´ë ¤ì›€ (ë””ë²„ê¹… ì‹œê°„ ì¦ê°€)

### SOLID 5ê°€ì§€ ì›ì¹™

#### Single Responsibility (ë‹¨ì¼ ì±…ì„ ì›ì¹™)

**ì •ì˜**: í•˜ë‚˜ì˜ í´ë˜ìŠ¤ëŠ” í•˜ë‚˜ì˜ ì±…ì„ë§Œ ê°€ì ¸ì•¼ í•¨

**âŒ ì˜ëª»ëœ ì˜ˆ:**
```gdscript
# building_manager.gd
func create_building(grid_pos):
    # ì¢Œí‘œ ë³€í™˜ë„ ì§ì ‘ í•¨ (ì±…ì„ 2ê°œ!)
    var world_pos = ground_layer.map_to_local(grid_pos)
    # ê±´ë¬¼ ìƒì„±
    var building = BuildingScene.instantiate()
```

**âœ… ì˜¬ë°”ë¥¸ ì˜ˆ:**
```gdscript
# building_manager.gd
func create_building(grid_pos):
    # ì¢Œí‘œ ë³€í™˜ì€ GridSystemì—ê²Œ ìœ„ì„ (ì±…ì„ 1ê°œ!)
    var world_pos = GridSystem.grid_to_world(grid_pos)
    # ê±´ë¬¼ ìƒì„±ë§Œ ë‹´ë‹¹
    var building = BuildingScene.instantiate()
```

**ì²´í¬ë¦¬ìŠ¤íŠ¸:**
- [ ] ê° í´ë˜ìŠ¤/ë§¤ë‹ˆì €ê°€ í•˜ë‚˜ì˜ ëª…í™•í•œ ì—­í• ë§Œ í•˜ëŠ”ê°€?
- [ ] í´ë˜ìŠ¤ ì´ë¦„ì´ ê·¸ ì—­í• ì„ ì •í™•íˆ í‘œí˜„í•˜ëŠ”ê°€?
- [ ] "ê·¸ë¦¬ê³ (AND)"ë¡œ ì—­í• ì„ ì„¤ëª…í•´ì•¼ í•œë‹¤ë©´ ì±…ì„ì´ 2ê°œ ì´ìƒ!

---

#### Open/Closed (ê°œë°©-íì‡„ ì›ì¹™)

**ì •ì˜**: í™•ì¥ì—ëŠ” ì—´ë ¤ìˆê³ , ìˆ˜ì •ì—ëŠ” ë‹«í˜€ìˆì–´ì•¼ í•¨

**âŒ ì˜ëª»ëœ ì˜ˆ:**
```gdscript
# building_manager.gd
func create_building(grid_pos):
    var world_pos = ground_layer.map_to_local(grid_pos)  # TileMapLayer ì§ì ‘ ì‚¬ìš©
    # â†’ TileMapLayer ë³€ê²½ ì‹œ BuildingManagerë„ ìˆ˜ì • í•„ìš”!
```

**âœ… ì˜¬ë°”ë¥¸ ì˜ˆ:**
```gdscript
# building_manager.gd
func create_building(grid_pos):
    var world_pos = GridSystem.grid_to_world(grid_pos)  # ì¶”ìƒí™” ì‚¬ìš©
    # â†’ TileMapLayer ë³€ê²½ ì‹œ GridSystemë§Œ ìˆ˜ì •í•˜ë©´ ë¨!
```

**ì²´í¬ë¦¬ìŠ¤íŠ¸:**
- [ ] ì‹œìŠ¤í…œ ë³€ê²½ ì‹œ í•œ ê³³ë§Œ ìˆ˜ì •í•˜ë©´ ë˜ëŠ”ê°€?
- [ ] ìƒˆ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ê¸°ì¡´ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì§€ ì•ŠëŠ”ê°€?

---

#### Liskov Substitution (ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™)

**ì •ì˜**: ìì‹ í´ë˜ìŠ¤ëŠ” ë¶€ëª¨ í´ë˜ìŠ¤ë¥¼ ì™„ì „íˆ ëŒ€ì²´í•  ìˆ˜ ìˆì–´ì•¼ í•¨

**ì ìš© ì˜ˆ:**
```gdscript
# base_entity.gd
class_name BaseEntity extends Node2D
func take_damage(amount: int) -> void:
    pass  # ê¸°ë³¸ êµ¬í˜„

# building_entity.gd
extends BaseEntity
func take_damage(amount: int) -> void:
    # ë¶€ëª¨ì˜ ê³„ì•½ì„ ìœ„ë°˜í•˜ì§€ ì•ŠìŒ!
    health -= amount
    update_visual()
```

**ì²´í¬ë¦¬ìŠ¤íŠ¸:**
- [ ] ìì‹ í´ë˜ìŠ¤ê°€ ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ë™ì‘ì„ ë³´ì¥í•˜ëŠ”ê°€?
- [ ] ìì‹ í´ë˜ìŠ¤ë¡œ êµì²´í•´ë„ í”„ë¡œê·¸ë¨ì´ ì •ìƒ ì‘ë™í•˜ëŠ”ê°€?

---

#### Interface Segregation (ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ ì›ì¹™)

**ì •ì˜**: í´ë¼ì´ì–¸íŠ¸ëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ë©”ì„œë“œì— ì˜ì¡´í•˜ì§€ ì•Šì•„ì•¼ í•¨

**Godot ì ìš©:**
- GDScriptëŠ” ì¸í„°í˜ì´ìŠ¤ê°€ ì—†ì§€ë§Œ, **ì‘ì€ í´ë˜ìŠ¤ë¡œ ë¶„ë¦¬**í•˜ëŠ” ê°œë… ì ìš©

**âŒ ì˜ëª»ëœ ì˜ˆ:**
```gdscript
# entity_manager.gd (ë„ˆë¬´ ë§ì€ ì±…ì„!)
func create_building()
func create_enemy()
func create_item()
func update_pathfinding()
func handle_collision()
# â†’ ê±´ë¬¼ë§Œ í•„ìš”í•œë° enemy, item ë©”ì„œë“œë„ ì˜ì¡´!
```

**âœ… ì˜¬ë°”ë¥¸ ì˜ˆ:**
```gdscript
# building_manager.gd (ê±´ë¬¼ë§Œ ë‹´ë‹¹)
func create_building()
func get_building()

# enemy_manager.gd (ì ë§Œ ë‹´ë‹¹)
func create_enemy()
func get_enemy()
```

**ì²´í¬ë¦¬ìŠ¤íŠ¸:**
- [ ] ë§¤ë‹ˆì €/ì‹œìŠ¤í…œì´ í•˜ë‚˜ì˜ ë„ë©”ì¸ë§Œ ë‹´ë‹¹í•˜ëŠ”ê°€?
- [ ] ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ë©”ì„œë“œë¥¼ ì–µì§€ë¡œ êµ¬í˜„í•˜ì§€ ì•ŠëŠ”ê°€?

---

#### Dependency Inversion (ì˜ì¡´ì„± ì—­ì „ ì›ì¹™) â­ ê°€ì¥ ì¤‘ìš”!

**ì •ì˜**: ê³ ìˆ˜ì¤€ ëª¨ë“ˆì€ ì €ìˆ˜ì¤€ ëª¨ë“ˆì— ì˜ì¡´í•˜ì§€ ì•Šê³ , ì¶”ìƒí™”ì— ì˜ì¡´í•´ì•¼ í•¨

**âŒ ì˜ëª»ëœ ì˜ˆ (í˜„ì¬ í”„ë¡œì íŠ¸ì—ì„œ ë°œìƒí–ˆë˜ ë¬¸ì œ!):**
```gdscript
# building_manager.gd (ê³ ìˆ˜ì¤€)
var ground_layer: TileMapLayer  # ì €ìˆ˜ì¤€ì— ì§ì ‘ ì˜ì¡´! âŒ

func create_building(grid_pos):
    var world_pos = ground_layer.map_to_local(grid_pos)  # TileMapLayer ì§ì ‘ ì‚¬ìš©
```

**êµ¬ì¡°:**
```
BuildingManager (ê³ ìˆ˜ì¤€)
    â†“ ì§ì ‘ ì˜ì¡´ âŒ
TileMapLayer (ì €ìˆ˜ì¤€ - Godot ë‚´ì¥)
```

**ë¬¸ì œ:**
- TileMapLayer ë³€ê²½ â†’ BuildingManagerë„ ìˆ˜ì • í•„ìš”
- EnemyManager, ItemManagerë„ ëª¨ë‘ TileMapLayer ì˜ì¡´
- ê²°í•©ë„ ë†’ìŒ (Tight Coupling)

**âœ… ì˜¬ë°”ë¥¸ ì˜ˆ (ë¦¬íŒ©í† ë§ í›„):**
```gdscript
# building_manager.gd (ê³ ìˆ˜ì¤€)
# TileMapLayer ì°¸ì¡° ì œê±°! âœ…

func create_building(grid_pos):
    var world_pos = GridSystem.grid_to_world(grid_pos)  # ì¶”ìƒí™”ì— ì˜ì¡´
```

**êµ¬ì¡°:**
```
BuildingManager (ê³ ìˆ˜ì¤€)
    â†“
GridSystem (ì¶”ìƒí™” ë ˆì´ì–´) â† ì´ê²ƒì´ í•µì‹¬!
    â†“
TileMapLayer (ì €ìˆ˜ì¤€)
```

**ì¥ì :**
- âœ… TileMapLayer ë³€ê²½ â†’ GridSystemë§Œ ìˆ˜ì •
- âœ… BuildingManagerëŠ” ë³€ê²½ ë¶ˆí•„ìš”
- âœ… í…ŒìŠ¤íŠ¸ ì‹œ GridSystemì„ Mockìœ¼ë¡œ êµì²´ ê°€ëŠ¥
- âœ… ê²°í•©ë„ ë‚®ìŒ (Loose Coupling)

**ì²´í¬ë¦¬ìŠ¤íŠ¸:**
- [ ] ê³ ìˆ˜ì¤€ ëª¨ë“ˆì´ Godot ë‚´ì¥ íƒ€ì…ì„ ì§ì ‘ ì°¸ì¡°í•˜ì§€ ì•ŠëŠ”ê°€?
- [ ] ì¶”ìƒí™” ë ˆì´ì–´(ë§¤ë‹ˆì €, ì‹œìŠ¤í…œ)ë¥¼ ê±°ì³ì„œ ì ‘ê·¼í•˜ëŠ”ê°€?
- [ ] ì˜ì¡´ì„± ë°©í–¥ì´ "ê³ ìˆ˜ì¤€ â†’ ì¶”ìƒí™” â†’ ì €ìˆ˜ì¤€"ì¸ê°€?

---

### ì‹¤ì „ ì ìš© ê°€ì´ë“œ

#### ìƒˆ ë§¤ë‹ˆì €/ì‹œìŠ¤í…œ ì¶”ê°€ ì‹œ ì²´í¬ë¦¬ìŠ¤íŠ¸

```gdscript
# âŒ ì´ë ‡ê²Œ í•˜ì§€ ë§ˆì„¸ìš”!
class_name EnemyManager extends Node

var ground_layer: TileMapLayer  # âŒ TileMapLayer ì§ì ‘ ì˜ì¡´

func create_enemy(grid_pos):
    var world_pos = ground_layer.map_to_local(grid_pos)  # âŒ ì§ì ‘ í˜¸ì¶œ
```

```gdscript
# âœ… ì´ë ‡ê²Œ í•˜ì„¸ìš”!
class_name EnemyManager extends Node

# ground_layer ì°¸ì¡° ì—†ìŒ! âœ…

func create_enemy(grid_pos):
    var world_pos = GridSystem.grid_to_world(grid_pos)  # âœ… GridSystem ì‚¬ìš©
```

#### SOLID ì²´í¬ë¦¬ìŠ¤íŠ¸

ì½”ë“œ ì‘ì„± ì „ì— í™•ì¸:

1. **Single Responsibility**
   - [ ] ì´ í´ë˜ìŠ¤ê°€ í•˜ëŠ” ì¼ì„ í•œ ë¬¸ì¥ìœ¼ë¡œ ì„¤ëª…í•  ìˆ˜ ìˆëŠ”ê°€?
   - [ ] "ê·¸ë¦¬ê³ (AND)"ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ì„¤ëª… ê°€ëŠ¥í•œê°€?

2. **Open/Closed**
   - [ ] ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ê¸°ì¡´ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì§€ ì•ŠëŠ”ê°€?
   - [ ] ì¶”ìƒí™” ë ˆì´ì–´ë¥¼ ì‚¬ìš©í•˜ëŠ”ê°€?

3. **Liskov Substitution**
   - [ ] ìƒì†ë°›ì€ í´ë˜ìŠ¤ê°€ ë¶€ëª¨ì˜ ë™ì‘ì„ ë³´ì¥í•˜ëŠ”ê°€?

4. **Interface Segregation**
   - [ ] ë§¤ë‹ˆì €ê°€ í•˜ë‚˜ì˜ ë„ë©”ì¸ë§Œ ë‹´ë‹¹í•˜ëŠ”ê°€?

5. **Dependency Inversion** â­
   - [ ] Godot ë‚´ì¥ íƒ€ì…ì„ ì§ì ‘ ì°¸ì¡°í•˜ì§€ ì•ŠëŠ”ê°€?
   - [ ] GridSystem, GameConfig ê°™ì€ ì¶”ìƒí™”ë¥¼ ì‚¬ìš©í•˜ëŠ”ê°€?

---

### ì‹¤ì œ í”„ë¡œì íŠ¸ ì˜ˆì‹œ

**ì˜¬ë°”ë¥¸ ì˜ì¡´ì„± êµ¬ì¡°:**

```
[ê³ ìˆ˜ì¤€ - ê²Œì„ ë¡œì§]
  BuildingManager
  EnemyManager
  ItemManager
       â†“
[ì¶”ìƒí™” ë ˆì´ì–´]
  GridSystem (ì¢Œí‘œ ë³€í™˜)
  GameConfig (ì„¤ì •)
       â†“
[ì €ìˆ˜ì¤€ - Godot ë‚´ì¥]
  TileMapLayer
  Sprite2D
  Area2D
```

**í•µì‹¬ ê·œì¹™:**
- âœ… ë§¤ë‹ˆì €ëŠ” **ì ˆëŒ€** Godot ë‚´ì¥ íƒ€ì…ì„ ì§ì ‘ ì°¸ì¡°í•˜ì§€ ì•ŠìŒ
- âœ… ëª¨ë“  ì¢Œí‘œ ë³€í™˜ì€ **GridSystem**ì„ í†µí•´ì„œë§Œ
- âœ… ëª¨ë“  ì„¤ì •ê°’ì€ **GameConfig**ë¥¼ í†µí•´ì„œë§Œ
- âœ… ê° ë§¤ë‹ˆì €ëŠ” **í•˜ë‚˜ì˜ ë„ë©”ì¸**ë§Œ ë‹´ë‹¹

---

### ì•ˆí‹° íŒ¨í„´ (ì ˆëŒ€ í•˜ì§€ ë§ ê²ƒ!)

```gdscript
# âŒ ì•ˆí‹° íŒ¨í„´ 1: ë§¤ë‹ˆì €ê°€ TileMapLayer ì§ì ‘ ì°¸ì¡°
class_name BuildingManager
var ground_layer: TileMapLayer  # âŒ

# âŒ ì•ˆí‹° íŒ¨í„´ 2: ë§¤ë‹ˆì €ê°€ ì¢Œí‘œ ë³€í™˜ ì§ì ‘ êµ¬í˜„
func create_building(grid_pos):
    var world_x = (grid_pos.x - grid_pos.y) * 16  # âŒ GridSystem ì—­í•  ì¹¨ë²”!

# âŒ ì•ˆí‹° íŒ¨í„´ 3: ë§¤ë‹ˆì €ê°€ ì—¬ëŸ¬ ë„ë©”ì¸ ë‹´ë‹¹
class_name GameManager
func create_building()  # ê±´ë¬¼
func create_enemy()     # ì 
func handle_ui()        # UI
# â†’ ì±…ì„ì´ 3ê°œ! ë¶„ë¦¬ í•„ìš”!
```

---

### 5.6. ì‹¤ì „ ì ìš©: Hidden Dependency ì œê±° (ë©”ì„œë“œ ì„¤ê³„) â­

**í•µì‹¬ ì›ì¹™**: ë©”ì„œë“œê°€ í•„ìš”ë¡œ í•˜ëŠ” ê²ƒì€ **íŒŒë¼ë¯¸í„°ë¡œ ëª…ì‹œ**í•˜ë¼. ìˆ¨ê²¨ì§„ ì˜ì¡´ì„±ì€ ë²„ê·¸ì˜ ì˜¨ìƒì´ë‹¤.

> "ë©”ì„œë“œì˜ ì‹œê·¸ë‹ˆì²˜ëŠ” ê³„ì•½(Contract)ì´ë‹¤. ë¬´ì—‡ì„ í•„ìš”ë¡œ í•˜ëŠ”ì§€ ëª…ì‹œì ìœ¼ë¡œ í‘œí˜„í•´ì•¼ í•œë‹¤."
> - Robert C. Martin, "Clean Code"

---

#### ë¬¸ì œ: Hidden Dependency (ìˆ¨ê²¨ì§„ ì˜ì¡´ì„±)

**ì •ì˜**: ë©”ì„œë“œê°€ ë©¤ë²„ ë³€ìˆ˜ì— ì•”ë¬µì ìœ¼ë¡œ ì˜ì¡´í•˜ì—¬, ì‹œê·¸ë‹ˆì²˜ë§Œ ë´ì„œëŠ” ë¬´ì—‡ì´ í•„ìš”í•œì§€ ì•Œ ìˆ˜ ì—†ëŠ” ìƒíƒœ

**âŒ ë¬¸ì œê°€ ìˆëŠ” ì½”ë“œ:**

```gdscript
# building_entity.gd
var data: BuildingData  # ë©¤ë²„ ë³€ìˆ˜

func _update_visuals() -> void:  # âš ï¸ ì‹œê·¸ë‹ˆì²˜ì— ì˜ì¡´ì„± í‘œí˜„ ì•ˆ ë¨
    if not data:  # ë©¤ë²„ ë³€ìˆ˜ì— ì•”ë¬µì  ì˜ì¡´
        push_warning("ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤!")
        return

    sprite.texture = data.sprite_texture
    sprite.scale = data.sprite_scale
```

**ì™œ ë¬¸ì œì¸ê°€?**

1. **ì‹œê·¸ë‹ˆì²˜ ë¶ˆëª…í™•**: `_update_visuals()`ë§Œ ë´ì„œëŠ” `data`ê°€ í•„ìš”í•œì§€ ëª¨ë¦„
2. **í˜¸ì¶œ ìˆœì„œ ì˜ì¡´ (Temporal Coupling)**: `data`ë¥¼ ë¨¼ì € ì„¤ì •í•´ì•¼ë§Œ í˜¸ì¶œ ê°€ëŠ¥
3. **í…ŒìŠ¤íŠ¸ ì–´ë ¤ì›€**: ë‹¤ì–‘í•œ ë°ì´í„°ë¡œ í…ŒìŠ¤íŠ¸í•˜ë ¤ë©´ ë§¤ë²ˆ ë©¤ë²„ ë³€ìˆ˜ ë³€ê²½ í•„ìš”
4. **ì¬ì‚¬ìš©ì„± ì €í•˜**: ë‹¤ë¥¸ `BuildingData`ë¡œ ì—…ë°ì´íŠ¸ ë¶ˆê°€ëŠ¥

---

#### í•´ê²°: Explicit Parameter (ëª…ì‹œì  íŒŒë¼ë¯¸í„°)

**âœ… ê°œì„ ëœ ì½”ë“œ:**

```gdscript
# building_entity.gd
var data: BuildingData  # ë©¤ë²„ ë³€ìˆ˜ëŠ” ìœ ì§€

## ë·°ë¥¼ ë°ì´í„°ì— ë§ê²Œ ê°±ì‹ í•˜ëŠ” ë‚´ë¶€ í•¨ìˆ˜
## @param building_data: ë¹„ì£¼ì–¼ ì—…ë°ì´íŠ¸ì— ì‚¬ìš©í•  BuildingData (ëª…ì‹œì  ì˜ì¡´ì„±)
func _update_visuals(building_data: BuildingData) -> void:  # âœ… íŒŒë¼ë¯¸í„°ë¡œ ëª…ì‹œ
    if not building_data:
        push_warning("ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤!")
        return

    sprite.texture = building_data.sprite_texture
    sprite.scale = building_data.sprite_scale

# í˜¸ì¶œ ì˜ˆì‹œ
func initialize(new_data: BuildingData) -> void:
    data = new_data
    _update_visuals(data)  # âœ… ëª…ì‹œì ìœ¼ë¡œ ì „ë‹¬
```

**ì¥ì :**

1. âœ… **ëª…ì‹œì  ê³„ì•½**: ì‹œê·¸ë‹ˆì²˜ë§Œ ë´ë„ `BuildingData`ê°€ í•„ìš”í•¨ì„ ì¦‰ì‹œ ì•Œ ìˆ˜ ìˆìŒ
2. âœ… **í˜¸ì¶œ ìˆœì„œ ë¬´ê´€**: ì–¸ì œë“ ì§€ í˜¸ì¶œ ê°€ëŠ¥ (Temporal Coupling ì œê±°)
3. âœ… **í…ŒìŠ¤íŠ¸ ìš©ì´**: ë‹¤ì–‘í•œ `BuildingData`ë¥¼ ì§ì ‘ ì „ë‹¬í•˜ì—¬ í…ŒìŠ¤íŠ¸
4. âœ… **ì¬ì‚¬ìš©ì„± í–¥ìƒ**: ëŸ°íƒ€ì„ì— ë‹¤ë¥¸ ë°ì´í„°ë¡œë„ ì—…ë°ì´íŠ¸ ê°€ëŠ¥ (ì˜ˆ: ê±´ë¬¼ ì—…ê·¸ë ˆì´ë“œ)
5. âœ… **í•¨ìˆ˜ ìˆœìˆ˜ì„±**: ì™¸ë¶€ ìƒíƒœë³´ë‹¤ íŒŒë¼ë¯¸í„°ì— ì˜ì¡´ (ìˆœìˆ˜ í•¨ìˆ˜ì— ê°€ê¹Œì›€)

---

#### Before / After ë¹„êµ

| í•­ëª© | Before (ë©¤ë²„ ë³€ìˆ˜ ì˜ì¡´) | After (íŒŒë¼ë¯¸í„° ì „ë‹¬) |
|------|------------------------|---------------------|
| **ëª…ì‹œì„±** | âŒ ìˆ¨ê²¨ì§„ ì˜ì¡´ì„± | âœ… ì‹œê·¸ë‹ˆì²˜ì— ëª…ì‹œ |
| **í˜¸ì¶œ ìˆœì„œ** | âš ï¸ data ë¨¼ì € ì„¤ì • í•„ìš” | âœ… ìˆœì„œ ë¬´ê´€ |
| **í…ŒìŠ¤íŠ¸** | âš ï¸ ìƒíƒœ ì„¤ì • í•„ìš” | âœ… ì§ì ‘ ì „ë‹¬ ê°€ëŠ¥ |
| **ì¬ì‚¬ìš©ì„±** | âš ï¸ dataë§Œ ì‚¬ìš© ê°€ëŠ¥ | âœ… ë‹¤ë¥¸ BuildingDataë„ ê°€ëŠ¥ |
| **SOLID ì›ì¹™** | ğŸŸ¡ Open/Closed ìœ„ë°˜ ê°€ëŠ¥ | âœ… ì™„ë²½ ì¤€ìˆ˜ |

---

#### ì‹¤ì „ ì²´í¬ë¦¬ìŠ¤íŠ¸

ë©”ì„œë“œ ì‘ì„± ì‹œ ë‹¤ìŒì„ í™•ì¸í•˜ì„¸ìš”:

1. **ì˜ì¡´ì„± ê²€í† **
   - [ ] ì´ ë©”ì„œë“œê°€ ë©¤ë²„ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ”ê°€?
   - [ ] ê·¸ ë©¤ë²„ ë³€ìˆ˜ê°€ ë©”ì„œë“œì˜ í•µì‹¬ ì…ë ¥ê°’ì¸ê°€?

2. **ëª…ì‹œì„± í™•ì¸**
   - [ ] ì‹œê·¸ë‹ˆì²˜ë§Œ ë´ë„ ë¬´ì—‡ì´ í•„ìš”í•œì§€ ì•Œ ìˆ˜ ìˆëŠ”ê°€?
   - [ ] ë‹¤ë¥¸ ê°œë°œìê°€ ë©”ì„œë“œ êµ¬í˜„ë¶€ë¥¼ ì½ì§€ ì•Šê³ ë„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ê°€?

3. **í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±**
   - [ ] ë‹¤ì–‘í•œ ì…ë ¥ê°’ìœ¼ë¡œ ì‰½ê²Œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œê°€?
   - [ ] ìƒíƒœ ì„¤ì • ì—†ì´ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ”ê°€?

**ê²°ì • ê·œì¹™:**
- âœ… ìœ„ 3ê°€ì§€ ì¤‘ í•˜ë‚˜ë¼ë„ "ì•„ë‹ˆì˜¤"ë¼ë©´ â†’ **íŒŒë¼ë¯¸í„°ë¡œ ë³€ê²½**
- ğŸŸ¡ ë©¤ë²„ ë³€ìˆ˜ê°€ ê°ì²´ì˜ "í•µì‹¬ ìƒíƒœ"ì´ê³ , ìì£¼ ë³€ê²½ë˜ì§€ ì•Šìœ¼ë©´ â†’ ìœ ì§€ ê°€ëŠ¥

---

#### ì˜ˆì™¸ ìƒí™©: ë©¤ë²„ ë³€ìˆ˜ ì‚¬ìš©ì´ ì •ë‹¹í•œ ê²½ìš°

**ë‹¤ìŒ ê²½ìš°ì—ëŠ” ë©¤ë²„ ë³€ìˆ˜ ì˜ì¡´ì´ í—ˆìš©ë©ë‹ˆë‹¤:**

1. **ë¶ˆë³€ ìƒíƒœ (Immutable State)**
   ```gdscript
   class_name BuildingEntity
   var entity_id: int  # ìƒì„± ì‹œ í•œ ë²ˆë§Œ ì„¤ì •, ì´í›„ ë¶ˆë³€

   func save_to_database() -> void:
       # entity_idëŠ” ê°ì²´ì˜ ì •ì²´ì„±ì´ë¯€ë¡œ ë©¤ë²„ ë³€ìˆ˜ ì‚¬ìš© ì •ë‹¹
       Database.save(entity_id, self.to_dict())
   ```

2. **ê°ì²´ì˜ í•µì‹¬ ì •ì²´ì„±**
   ```gdscript
   class_name Player
   var health: int  # í”Œë ˆì´ì–´ì˜ í•µì‹¬ ìƒíƒœ

   func is_alive() -> bool:
       # healthëŠ” Playerì˜ ì •ì²´ì„±ì´ë¯€ë¡œ ë©¤ë²„ ë³€ìˆ˜ ì‚¬ìš© ì •ë‹¹
       return health > 0
   ```

3. **ë‚´ë¶€ ìºì‹œ/í—¬í¼ ë³€ìˆ˜**
   ```gdscript
   class_name PathFinder
   var _grid_cache: Dictionary  # ë‚´ë¶€ ìµœì í™”ìš© ìºì‹œ

   func _calculate_distance(a: Vector2i, b: Vector2i) -> float:
       # _grid_cacheëŠ” ë‚´ë¶€ êµ¬í˜„ ì„¸ë¶€ì‚¬í•­ì´ë¯€ë¡œ íŒŒë¼ë¯¸í„° ë¶ˆí•„ìš”
       if _grid_cache.has(a):
           return _grid_cache[a].distance_to(b)
   ```

**í•µì‹¬ êµ¬ë¶„ ê¸°ì¤€:**
- **ì…ë ¥ ë°ì´í„°** â†’ íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬ âœ…
- **ê°ì²´ì˜ ìƒíƒœ** â†’ ë©¤ë²„ ë³€ìˆ˜ ìœ ì§€ ê°€ëŠ¥ ğŸŸ¡
- **ë‚´ë¶€ êµ¬í˜„ ì„¸ë¶€ì‚¬í•­** â†’ ë©¤ë²„ ë³€ìˆ˜ ìœ ì§€ ğŸŸ¡

---

#### ì‹¤ì œ í”„ë¡œì íŠ¸ ì ìš© ì‚¬ë¡€

**íŒŒì¼**: `scripts/entity/building_entity.gd`

**ë¦¬íŒ©í† ë§ ì „ (Hidden Dependency):**
```gdscript
var data: BuildingData

func _update_visuals() -> void:
    if not data:  # âŒ ìˆ¨ê²¨ì§„ ì˜ì¡´ì„±
        return
    sprite.texture = data.sprite_texture
```

**ë¦¬íŒ©í† ë§ í›„ (Explicit Parameter):**
```gdscript
var data: BuildingData

func _update_visuals(building_data: BuildingData) -> void:
    if not building_data:  # âœ… ëª…ì‹œì  íŒŒë¼ë¯¸í„°
        return
    sprite.texture = building_data.sprite_texture

func initialize(new_data: BuildingData) -> void:
    data = new_data
    _update_visuals(data)  # âœ… ëª…ì‹œì  ì „ë‹¬
```

**ê°œì„  íš¨ê³¼:**
- âœ… Dependency Inversion ì›ì¹™ ì™„ë²½ ì¤€ìˆ˜
- âœ… í…ŒìŠ¤íŠ¸ ì‹œ ë‹¤ì–‘í•œ BuildingDataë¡œ ê²€ì¦ ê°€ëŠ¥
- âœ… í–¥í›„ ê±´ë¬¼ ì—…ê·¸ë ˆì´ë“œ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ì¬ì‚¬ìš© ê°€ëŠ¥

---

#### ê´€ë ¨ SOLID ì›ì¹™

ì´ íŒ¨í„´ì€ ë‹¤ìŒ SOLID ì›ì¹™ê³¼ ì—°ê²°ë©ë‹ˆë‹¤:

1. **Single Responsibility**
   - ë©”ì„œë“œê°€ "ë°ì´í„° ê°€ì ¸ì˜¤ê¸°"ì™€ "ë¹„ì£¼ì–¼ ì—…ë°ì´íŠ¸"ë¥¼ ë™ì‹œì— í•˜ì§€ ì•ŠìŒ
   - ë°ì´í„°ëŠ” ì™¸ë¶€ì—ì„œ ì£¼ì… â†’ ë©”ì„œë“œëŠ” ì—…ë°ì´íŠ¸ë§Œ ë‹´ë‹¹

2. **Open/Closed**
   - ë‹¤ë¥¸ íƒ€ì…ì˜ ë°ì´í„°ë¡œ í™•ì¥ ê°€ëŠ¥ (íŒŒë¼ë¯¸í„°ë§Œ ë³€ê²½)
   - ë©”ì„œë“œ ë‚´ë¶€ëŠ” ìˆ˜ì • ë¶ˆí•„ìš”

3. **Dependency Inversion**
   - ë©”ì„œë“œê°€ êµ¬ì²´ì  ë©¤ë²„ ë³€ìˆ˜ë³´ë‹¤ ì¶”ìƒì  íŒŒë¼ë¯¸í„°ì— ì˜ì¡´
   - ê²°í•©ë„ ë‚®ì¶¤ (Loose Coupling)

---

## 6. ì•„í‚¤í…ì²˜: ë¡œì§ê³¼ UI ë¶„ë¦¬

ê²Œì„ ë¡œì§(ë°ì´í„°/ìƒíƒœ)ê³¼ UI(í‘œí˜„)ë¥¼ ì—„ê²©í•˜ê²Œ ë¶„ë¦¬í•˜ì—¬, UIê°€ ë³€ê²½ë˜ì–´ë„ ê²Œì„ ë¡œì§ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.

### 6.1. ì˜ì¡´ì„± ë°©í–¥
- **ë¡œì§ -> UI (X)**: ê²Œì„ ë¡œì§ ìŠ¤í¬ë¦½íŠ¸ëŠ” UI ë…¸ë“œë¥¼ ì§ì ‘ ì°¸ì¡°í•˜ê±°ë‚˜ ì œì–´í•˜ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤.
- **UI -> ë¡œì§ (O)**: UI ìŠ¤í¬ë¦½íŠ¸ëŠ” ê²Œì„ ë¡œì§(ë°ì´í„°)ì„ ì°¸ì¡°í•˜ì—¬ í™”ë©´ì„ ê°±ì‹ í•©ë‹ˆë‹¤.

### 6.2. í†µì‹  ë°©ì‹ (Signals - Observer Pattern)
- ê²Œì„ ë¡œì§ ìƒíƒœê°€ ë³€ê²½ë˜ë©´ **Signal**ì„ ë°©ì¶œ(emit)í•©ë‹ˆë‹¤.
- UIëŠ” í•´ë‹¹ Signalì„ ì—°ê²°(connect)í•˜ì—¬ í™”ë©´ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

```gdscript
# Player.gd (Logic)
signal health_changed(new_health: int)

func take_damage(amount: int) -> void:
    health -= amount
    health_changed.emit(health) # UI ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•´ ì‹ í˜¸ë§Œ ë°©ì¶œ

# HUD.gd (UI)
func _ready() -> void:
    player.health_changed.connect(_on_player_health_changed)

func _on_player_health_changed(new_health: int) -> void:
    health_bar.value = new_health # UI ë³€ê²½ ë¡œì§
```
